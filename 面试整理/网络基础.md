[TOC]



# 网络层级

![](https://upload-images.jianshu.io/upload_images/944365-8f04f1321143fd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620)

![](https://upload-images.jianshu.io/upload_images/944365-73d7d56b1f54d945.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/780)

# TCP

`Transmission Control Protocol`，即 传输控制协议。

属于 传输层通信协议，基于`TCP`的应用层协议有`HTTP`、`SMTP`、`FTP`、`Telnet` 和 `POP3`

## 头部

- **TCP端口号**
  TCP的连接是需要四个要素确定唯一一个连接：
  **（源IP，源端口号）+ （目地IP，目的端口号）**
  所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递
  源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535
  另外1024以下是系统保留的，从1024-65535是用户使用的端口范围

- **TCP的序号和确认号**：
  **32位序号 seq**：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据**有序**，比如现在序列号为1000，发送了1000，下一个序列号就是2000。
  **32位确认号 ack**：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。

- **TCP的标志位**
  每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。
  用的最广泛的标志是 **SYN**，**ACK** 和 **FIN**，用于建立连接，确认成功的段传输，最后终止连接。

1. **SYN**：简写为`S`，同步标志位，用于建立会话连接，同步序列号；
2. **ACK**： 简写为`.`，确认标志位，对已接收的数据包进行确认；
3. **FIN**： 简写为`F`，完成标志位，表示我已经没有数据要发送了，即将关闭连接；
4. PSH：简写为`P`，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
5. RST：简写为`R`，重置标志位，用于连接复位、拒绝错误和非法的数据包；
6. URG：简写为`U`，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；

## 三次握手建立连接

![img](https:////upload-images.jianshu.io/upload_images/944365-5527d827865f8d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

注意：ack和ACK，不是同一个概念：

- 小写的ack：头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。
- 大写的ACK：TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。

### 为什么TCP建立连接需三次握手？

防止服务器端因接收了**早已失效的连接请求报文**，从而一直等待客户端请求，最终导致**形成死锁、浪费资源**

## 四次挥手关闭连接

由于TCP连接是**全双工**的，因此，每个方向都必须要单独关闭，这一原则是当一方发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

![img](https:////upload-images.jianshu.io/upload_images/944365-82c3290a6135a610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

### 为什么TCP释放连接需四次挥手？

为了**保证通信双方都能通知对方 需释放 & 断开连接**





# HTTP版本之间区别

[参考链接](https://blog.csdn.net/qq_40860852/article/details/93632106)

## 1.0版本

- 支持GET命令还有POST和HEAD等请求方法。
- HTTP的请求和回应格式也发生了变化，除了要传输的数据之外，每次通信都包含头信息，用来描述一些信息。
- 同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。
- 除了数据部分，每次通信都必须包括头信息（HTTP header）。
-  但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持 keep-alive。

## 1.1版本

- 引入了持久连接，TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
- 加入了管道机制，在同一个TCP连接里，允许多个请求同时发送，增加了并发性，进一步改善了HTTP协议的效率。举例：允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。
- 分块传输
- 新增了请求方式PUT、PATCH、OPTIONS、DELETE等。
- 支持文件断点续传

## 2.0版本

- **多工：** HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"（HTTP2.0使用了`多路复用的技术`，做到同一个连接并发处理多个请求）。
- **二进制协议：** HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
- **头信息压缩：** HTTP 协议不带有状态，每次请求都必须附上所有信息。
  1. 头信息使用gzip或compress压缩后再发送
  2. 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，只发送索引号。
- **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源

# SSL 非对称加密

1. **客户端发起HTTPS请求**

这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

2. **服务端的配置**

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。

这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

3. **传送证书**

这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

4. **客户端解析证书**

这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

5. **传送加密信息**

这部分传送的是用**证书加密后的随机值**，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. **服务段解密信息**

服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

7. **传输加密后的信息**

这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。

8. **客户端解密信息**

客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

