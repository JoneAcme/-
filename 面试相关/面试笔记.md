**面试题整理**

[TOC]



 

## JVM相关

### JVM内存模型

#### 程序计数器(线程私有)

当前线程所执行的字节码行号指示器。

 

#### java虚拟机栈(线程私有)

描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应一个栈帧再虚拟机栈中入栈到出栈的过程。

Java虚拟机规范中，对这个区域规定了两种异常的状况：

1. 如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError

2. 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

 

#### 本地方法栈(线程私有)

与虚拟机栈发挥的作用是非常相似的，它们之间的区别不过是：

虚拟机栈为虚拟机执行Java方法（字节码）服务。

本地方法栈则为虚拟机使用到的Native方法服务。

 

#### java堆

Java堆是被所有线程共享的一块内存区域，在虚拟机创建时创建。此内存区域唯一的目的就是存放对象实例。所有的对象实例以及数组都要在堆上分配。

 

#### 方法区

所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。

相对而言，垃圾收集行为在这个区域是较少出现的，但并非数据进入了方法区就如永久代的名字一样，永久存在了，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

当方法去无法满足内存分配需求时，会抛出OutOfMemoryError异常

 

#### 运行时常量池

是方法区的一部分，出了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量放入池中。

 

#### 直接内存(虚拟机外内存)

并不是虚拟机运行时的一部分，也不是Java虚拟机规范中定义的内存区域。

使用：1.4中加入的NIO（New Input/Output）中，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native函数库直接分配堆外内存然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据，能显著提高性能。

### 垃圾回收

#### 引用计数法

对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1；当引用失效时，计数器-1。任何时刻计数器为0的对象就是不可能再被使用的。

缺点：相互引用着对方，导致引用计数都不为0，无法通知GC收集器回收它们。

#### 可达性分析法

通过一系列成为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径成为引用链，当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的，被判定为可回收对象。

可作为GC Roots的对象包括：

1.     虚拟机栈（栈帧中的本地变量表）中引用的对象

2.     方法区中静态属性引用的对象

3.     方法区中常量引用的对象

4.     本地方法栈中JNI（Native方法）引用的对象

#### Java中的四种引用

1.     强引用

普遍存在的，直接New出来的，只要强引用还在，垃圾回收器永远不会回收掉被引用的对象

2.     软引用

内存发生溢出之前，才会回收。SoftReference

3.     弱引用

不管内存是否足够，只要发现，就会被回收。WeakReference

4.     虚引用

一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时，收到一个系统通知。PhantomReference

#### 回收方法区

可以不要求虚拟机在方法区实现垃圾收集，毕竟方法区进行垃圾收集的性价比一般较低。

​       永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

​       废弃常量：是否有引用。

​       无用的类（同时满足以下三个条件）：

1.     该类所有的实例都已经被回收，Java堆中不存在该类的任何实例

2.     加载该类的ClassLoader已经被回收

3.     该类对应的java.lang.Class对象没有再任何地方被引用，无法在任何地方通过反射访问该类的方法

注：这里说的仅仅是可以，而并不是和对象一样，不使用了就必然会被回收

 

#### 标记-清除

步骤：

1.     首先标记处所有需要回收的对象

2.     在标记完成后统一回收所有被标记的对象

不足：

1．   效率问题。标记和清除两个过程的效率都不高

2．   空间问题。标记清除后悔产生大量不连续的内存碎片，导致以后在程序运行过程中需要分配较大对象时，无法找到足够连续的内存，而不得不提前出发另一次垃圾收集动作

#### 复制算法

将内存区域划分为两部分，每次只使用其中的一块，当这一块快用完了，就将还存活的对象复制到另一块内存上，然后把当前使用过的这块一次性清理掉。

优点：

不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可

​       缺点：

​              内存使用率缩减

 

**复制算法优化**：

将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。如今默认的Eden和Survivor对象大小比例是8:1。

不能保证每次回收都只有不多于10%的对象存货，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

当另一块Survivor空间没有足够的空间存放上一次新生代收集下来存货对象时，这些对象将直接通过分配担保进入老年代。

#### 标记-整理

​       标记整理算法过程仍与标记清除算法一样，但后续步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉其他内存。

#### 分代回收

​       根据对象存活的周期，将内存分为新生代和老年代。

​       新生代：对象存活率低，每次都有大量对象死去，采用复制算法。

​       老年代：对象存活率高，没有额外的内存对它进行内存担保，所以使用标记清理或者标记整理算法。

 

#### 垃圾回收器

可达性分析对执行时间的敏感中的一致性：

​       整个可达性分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过成中对象引用关系还在不断变换的情况，该点不满足的话，分析结果准确性就无法得到保障。这点是导致GC进行时必须停顿所有Java执行线程（Stop The world）的其中一个重要原因。

​       安全点：程序执行时并非在所有的地方都能停顿下来GC，只有在到达安全点时才能暂停。安全点的选定既不能太少让GC等待时间太长，也不能过于频繁以至于过分增大运行时负荷，所以安全点的选定，基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。包含抢先式中断和主动式中断

​       抢先式中断：不需要线程的执行代码主动去配合，GC发生时，首先把所有的线程全部中断，如果发现有线程的中断店不在安全点上，就恢复线程，让它跑到中断点上。

​       主动式中断：当GC需要中断线程时，不直接对线程操作，仅仅简单的设置一个标志，各个线程主动去轮询这个标志，发现中断标志为真时，就自己中断挂起。

​       安全区域：如果线程处于Sleep或者Block状态，无法响应JVM的中断请求，就需要安全区域解决。指在一段代码片段之中，引用关系不会发生变化，这个区域中的任何地方开始GC都是安全的

1.     Serial收集器

单线程收集器，并不仅仅说明只会使用一个CPU或一条收集线程去完成垃圾收集工作，重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。

2.     ParNew 收集器

Serial收集器的多线程版本

3.     Parallel Scavenge 收集器

复制算法收集器，

4.     Serial Old收集器

采用标记整理算法的单线程收集器

5.      Parallel Old 收集器

多线程和标记整理算法

6.      CMS 收集器

标记清除算法

7． G1收集器

并行与并发、分代收集、标记整理

#### 内存分配与回收策略

1.     对象优先在Eden分配

大多数情况下，对象在新生代Eden中分配。当Eden区中没有足够的空间分配时，虚拟机将发起一次Minor GC，如果空间还不够，大对象直接进入老年代。

2.     长期存活的对象将进入老年代

从Eden中每经过一次GC，增加1，默认达到15时，晋升如老年代。但并不是必须要达到规定数值，如果在Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，大于或等于该数值的对象，直接进入老年代

 

 

### 线程相关

线程的状态

线程创建：继承Thread、实现Runnable、实现Callable

线程池

 

### 类加载

#### 类加载过程

加载-验证-准备-解析-初始化-使用-卸载

1.     加载

1)     通过一个类的全限定名来获取定义此类的二进制字节流

2)     将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

3)     在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的歌中数据的访问入口

2.     验证

目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的自身安全。

3.     准备

正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。这里内存分配的仅包括类变量（static变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

注：

例：public static int value = 123；变量在准备阶段的初始化过后的初始化为0而不是123，赋值指令是在程序编译后，存放于类构造器方法中，赋值动作将在初始化阶段才会执行。

4.     解析

将常量池中的符号引用替换为直接引用的过程。

5.     初始化

初始化类，真正开始执行类中定义的Java程序代码（字节码）。

 

#### 双亲委派

工作过程：

如果一个类加载器收到了类加载请求，首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈无法自己完成这个加载请求时，子加载器才会尝试自己去加载。

 

 

#### 类加载器

比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则只要加载它们的类加载器不同，这两个类也就必定不相等。（包括Instanceof 关键字运算结果）

 

1.     启动类加载器Bootstrap ClassLoader

2.     扩展类加载器Extension ClassLoader

3.     应用程序类加载器Application ClassLoader，也被成为系统加载器

  



 

## JAVA基础相关

## 反射

## 泛型

泛型擦除：Java中的泛型，不是真正的泛型，只在源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型。

```java 
public static void main(String[] args){
	Map<String,String> map = new HashMap<String,String>();
	map.put("abc","123");
	map.put("efg","345");
	System.out.println(map.get("abc"));
	System.out.println(map.get("efg"));
}
```

编译后：

```java 
public static void main(String[] args){
	Map map = new HashMap();
	map.put("abc","123");
	map.put("efg","345");
	System.out.println((String)map.get("abc"));
	System.out.println((String)map.get("efg"));
}
```

当泛型遇到方法重载

例：

```java
public static GenericTypes {
  
    public static void method(List<String> list){

    }
  
    public static void method(List<Integer> list){

    }

}
```

上方两个方法， 在擦除后，变成了一样的远程类型List<E>，导致两种方法的特征签名一模一样，所以编译无法通过。

 

### HashMap

HashMap 是基于 Map 接口实现的一种键-值对<key,value>的存储结构，允许 null 值，同时非有序，非同步(即线程不安全)。HashMap 的底层实现是数组 + 链表 + 红黑树（JDK1.8 增加了红黑树部分）。

HashMap 定位元素位置是通过键 key 经过扰动函数扰动后得到 hash 值， 然后再通过 hash & (length - 1)代替取模的方式进行元素定位的。

HashMap 是使用链地址法解决 hash 冲突的，当有冲突元素放进来时，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表 长度大于等于 8 时，HashMap 会将链表 转变为 红黑树，以此提高查找效率。

HashMap 的容量是 2 的 n 次方，有利于提高计算元素存放位置时的效率， 

也降低了 hash 冲突的几率。

HashMap 不是线程安全的，Hashtable 则是线程安全的。但 Hashtable 是一个遗留容器，如果我们不需要线程同步，则建议使用 HashMap，如果需要线程同步，如果想线程安全，可以通过调用synchronizedMap(Map<K,V> m)使其线程安全。但是使用时的运行效率会下降，所以建议使用 ConcurrentHashMap 容器以此达到线程安全。

在多线程下操作 HashMap，由于存在扩容机制，当 HashMap 调用 resize() 进行自动扩容时，可能会导致死循环的发生。 

 

**LinkedList**

实现了 List 接口的双向链表。实现了所有可选列表操作，并且可以存储所有类型的元素，包括 null。 

LinkedList 是非同步的。若需要同步处理，应使Collections.synchronizedList 来包装

 

**HashSet**

（1）HashSet 内部使用 HashMap 的 key 存储元素，以此来保证元素不重复； 

（2）HashSet 是无序的，因为 HashMap 的 key 是无序的； 

（3）HashSet 中允许有一个 null 元素，因为 HashMap 允许 key 为 null； 

（4）HashSet 是非线程安全的； 

（5）HashSet 是没有 get()方法的；

 

 



 

## 网络相关

### http/https

### TCP/IP

### Socket



###  

## 设计模式

### 六大原则



###  

## Android相关 todo